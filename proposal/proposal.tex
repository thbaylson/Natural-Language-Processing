\documentclass[12pt]{article}
\usepackage[letterpaper]{geometry}
\usepackage{times}
\usepackage{listings}
\usepackage{graphicx}
\usepackage{caption}
\usepackage{fancyhdr}
\usepackage{amsmath}
\usepackage{array}
\usepackage{enumitem}

\setlength{\parindent}{2em}
\setlength{\parskip}{1em}

\renewcommand{\ttdefault}{pcr}
\lstset{language=Python, numbers=none, basicstyle=\ttfamily\footnotesize,
        showstringspaces=false}
\newcommand{\code}[1]{\texttt{#1}}

%%%
%   
%   Capstone Proposal
%
%   Tyler Baylson
%   Andrew Sexton
% 
%%%

\begin{document}

\lhead{
    CS 496: Capstone II Proposal
}
\rhead{
    Tyler Baylson, Andrew Sexton     
}

% The title
\title{Capstone II Proposal: Converting an English Sentence to a Format Understandable by Computers}
\author{Tyler Baylson, Andrew Sexton}
\date{Fall, 2020}
\maketitle

\section{Introduction}
% What is the problem? \\
Shared file systems, whether based on local storage or storage "in the cloud", bring an increased level of work efficiency from their users. Given the growing methods of shared access and collaboration, however, the data within is often at greater risk than many users might presume. This level of convenience requires a great amount of responsibility, and in a worst case scenario where a credential file itself may be accessed by an unauthorized user, a security failure cascade may lead to very serious problems for the company.

% Why is it important? \\
So it is essential that users are able to easily and efficiently manage access to their data on these shared filesystems, and the greater the granularity, the more security management itself may become part of the user's workflow. This workflow could include everything from simple privacy rule establishment to fully customized schedules of access.

% How do you plan to solve it? \\
Natural language is of course the most intuitive way to guide the performance of a task, and making natural language processing available to the end-user to establish security rules and query access would allow for easy and effective means to protect information and resources. 

Our system for policy based access control implements a well-formed notation (described below) for both specifying access control policies and authorizing access when inquiries against data are made. In this way, the definition of policies becomes simpler and more efficient, which will allow users to protect their assets under their own terms, and will ensure that requesters can feed access requests to the system just as simply.

\section{Problem Definition}
% Briefly describe the data that you used (or plan to use).\\ 
All types of data in a file system are at risk when access is not defined or if that access is defined in an unclear or incomplete manner. Our system accepts user input and determines the intent of a given security policy or access inquiry for the extant data on a network or filesystem which implements our access control methods.

% What do people usually try to do with the data? \\
While typical access for a given file may be legitimate, when the owner of data is not able to (or aware of how to) adjust or monitor access (especially given the complexity of certain team-based file access), it’s easy for security requirements to relax. The data goes either unsecured or unmonitored, increasing unnecessary risk.

% Why is it difficult to do what they want to do? \\
A given network with subjects, objects, and defined relationships can be interpreted as a directed labeled graph (vertices connected by edges)
\begin{enumerate}
    \item $N$ is a finite set of subjects $(S)$ and objects $(O)$, that may include an environmental condition.
    \item $\Sigma$ is a finite set of relationship types (labels for connections).
    \item $W$ is a number attached to a relationship between two subjects. This is a percentage of trust between two users.
    \item $E \subseteq N \times N \times \Sigma \times W$ represents the edges of existing connections, the relationships between subjects and objects, objects and other objects, and represents a general overview of the possible authorized interactions within that network\cite{morovat16}.
\end{enumerate}

% What specific data did you use (or plan to use)? What is the source? \\
Though programs can be written for security management, they would simply be another step in the chain that would require attention, setup, and maintenance. Much research has been performed, some of which is cited within this proposal, but no specific approach has proven quite flexible enough for general use within social networks.

% What are the specific user requirements? \\
Our system must process natural user command sentences in a given structure within a basic UI, resulting in appending well-formatted data to a policy file in the user's directory. This only requires a simple UI for access control input, and our current implementation could easily transition to a desktop application or intranet-based web-application. During this second phase of Capstone, we will embrace abstraction to broaden its access to allow it greater flexibility, as companies may wish to have more granular control over its presentation. In the event of an error in input or authorization attempt, depending on certain circumstances, the program may ask for further clarification. A program already exists which will manage reading the policy rules and acting on user queries, and it also handles conflicts, giving priority to most recent policy input.

% List a company and organization that may use the features of this program. \\
We consider that this program will be useful for companies that emphasize team-based access to shared files, especially where leadership is comprised of users for whom it is not time-efficient to learn the details of things like `chmod` commands. Even Western Carolina University would benefit from implementing this approach, and it goes without saying that more general social networks such as Facebook might benefit from users who would like to take a more involved stance on how their posted files are seen by other users.

\section{Solution}

% List/explain the alternate solutions available.  Why did you not use other solutions? \\
Numerous solutions to access control have been theorized: Fong et al. defined an access control model that employed authorization decisions in terms of the relationships between the resource owner and a resource requester \cite{fong11}. This solution, however, only addresses the case of simple expressions of policies and become equally simple rules -- this does not reflect the complex nature of actual networks as demonstrated above. Aktoudianakis et al. defined a syntax for specifying a social network and its associated access control policies, which allows for rather simple generation of policies. But the syntax discussed does not implement the direct association with users to define effective policies \cite{aktoudianakis13}. Some solutions have suggested an XML-based format, including Extensible Access Control Markup Language (XACML). This language uses XML to generate both an access control policy language and a request/response language, but a simpler approach would be able to process policies and inquiries in natural expressions without the constraints of XML tags \cite{damiani02}.

Though we may implement XML or JSON formatted data in our logging functionality, we will likely not be using it as a part of the business logic itself.

During our final presentation for Capstone I, it was asked whether we might have considered using Prolog or other declarative language approaches. This is absolutely a possible option, but relies on an expert system approach: based on a knowledgebase and rule, it would make proactive decisions about incoming data. Our application and the scope for which it is originally intended relies on a more reactive approach. 

% Why do you plan on using the solution that you chose? \\
Our solution stands as a faithful implementation of Dr. Morovat's own Policy Based Language for Access Control \cite{morovat16}. It simultaneously respects the complexities of a network with subjects, objects, and environmental availability conditions while also achieving a simple outcome. The Policy-Based Attribute Access Control model allows its users to use a natural language to communicate policies, empowering authorized users to take control of their data and reduces risk using natural language requests such as “Bob can edit my tasklist documents on weekdays” and "only I can edit my tasklist documents after 1pm Friday".

Users may currently define policies and make inquiries in English via an access control interface. The program transforms user defined policies, using the well-formed format described below, into system rules. It will also transform user inquiries into the well-formed format and process these as system queries.

Given sentences may be in the format: Subject verb object [conditional(time/date)]. As an example, "Alice is allowed to access photos."
The system will recognize 'Access' words like "Read", "write", and "modify", including common negations. Objects themselves may be referenced by filetype (i.e. "photos" = jpg, gif, etc, and "documents" = txt, docx, etc.). The system differentiates between types of entities in a given network as modeled above:
\begin{itemize}
    \item Target users, which get policies protecting them from unauthorized access
    \item Target resources, which get policies protecting them from unmanaged actions
\end{itemize}
It places inquiries into two groups:
\begin{itemize}
    \item Attempting to perform an operation against resources like updating or deleting resource
    \item Attempting to access target users (e.g. Facebook may consider this in terms of 'tagging' in a photo or 'poking' a target user)
\end{itemize}
The well-formed format template we use indicates the following:
\begin{itemize}
    \item Words in policy/ inquiry appear with order: subject, verb, object
    \item Words in rule/request appear with order: subject, action, object
\end{itemize}

The system itself operates on a simple console-based UI, but the Controller is implemented such that a GUI which follows the same UI programming conventions would work in various file system configurations and social networks. Please refer to Table \ref{table:1} for our MoSCoW table of further feature considerations.

In terms of develoment improvements for Capstone II, we will be implementing `pip` as a dependency management system, with a `requirements.txt` file in place that will ensure a consistent development environment. We will implement more object oriented approaches (even in our primarily functional paradigm) to ensure a more flexible class structure. This will give us the ability to extend at least our logging and UI functionality to other potential requirements. None are currently forseen, but looser coupling is desirable.

As mentioned, we are implementing a log of all entries and their corresponding results. Along with this, we are implementing `numpy` and `pandas` for the beginnings of an analytics framework. Besides the obvious infographics, its purpose will be to help administrators gain some visibility on the most common behaviors by users in the system, indicating most frequently referenced users, files, and directories. It will also monitor for suspicious activity, i.e., requests being made at an inhumanly consistent or fast rate, potentially intentional attempts to overflow the logs, probing for files without correct filenames in a suspect manner, etc.

Ideally we would also like to include more implicit grammar handling and using the analytics to make administrative requests for aliases. For example, if "Becky" is often used in a failing request while "Rebecca" quickly follows in a successful one, it may be fair to assume that the two users are the same. Similar behavior could be implemented for filenames and directories.

% Describe and show a storyboard that illustrates how the new components of your system will be used. \\
Users may start our program via command line or graphical application. They may then type access control commands into the program. These commands may be written as natural-sounding sentences. The program will then parse the sentence into individual words. These individual words are then processed through Spacy's lexical database to ascertain their grammatical and syntactical significance. The program will use the grammatical and syntactical data to generate a well-formed policy rule for access control based on the original natural-sounding sentence. The newly generated policy will be cross examined with an existing policy text file to ensure the same policy does not already exist. If the newly generated policy does not exist in the policy text file, it will be appended to the policy text file. Dr. Morovat’s own program handles the security activities as determined by the policy rule or inquiry.

\section{Plan}

% How will you test the system? \\
Please refer to Table \ref{table:2} for our semester schedule of implementations.

We will utilize the pytest framework to help streamline the development process and encourage test driven development for the system as it gains complexity. On that note, we have also reviewed how specific courses we have completed will reflect in this project:
\begin{enumerate}
    \item CS 150 \& 151, Introduction to Problem-Solving I \& II: Basic python comprehension and working with data structures
    \item CS 263, Software Engineering: Breaking down the project into tasks, preparing proposal, specifics like the MoSCoW analysis, etc.
    \item CS 351, Data Structures and Algorithms: Graph data structures and traversal
    \item CS 352, Programming Languages: Further functional and object-oriented data processing, preparaing input for parsing
    \item Math 270, Statistics: Any analytics we perform in Capstone II are likely to build on the principles of 270
    \item Math 310, Discrete Structures: Learning about graph structures and, more specifically, markov chains, which are applicable to our WordNet approach
    \item And on our own, we will be learning learn PyTest and approaches to implement a theoretical model in programming practice (PBAAC).
\end{enumerate}

\begin{table}[p]
    \begin{center}
        \begin{tabular}{ | m{1.3in} | m{1.3in}| m{1.3in} | m{1.3in} | } 
        \hline
        Must Have & Should Have & Could Have & Won't Have \\ 
        \hline
        \hline
        Continued PBAAC Implementation & Stop word recognition & Implicit grammar handling & Social network for implementation \\ 
        \hline
        Class-based separation of concerns & More human-friendly output on request & Aliasing based on analytics & Adding weight to specific individual names on network  \\ 
        \hline
        Analytics of logged inputs and outputs & Handling of environmental (date/time) conditions & Encryption of policy files & \\ 
        \hline
        Visualizations for analytics  &   & Encryption of Policy File &   \\ 
        \hline
          &  Reporting of suspicious activity based on analytics & & Mobile device recognition of environmental contexts  \\ 
        \hline
        \end{tabular}
        \caption{MoSCoW Board}
        \label{table:1}
    \end{center}
\end{table}

\begin{table}[p]
    \begin{center}
        \begin{tabular}{ | m{0.4in} | m{4in}| m{1.6in} | }
        \hline
        Date & Deliverable & Item Due \\ 
        \hline
        09/01/20 & Sprint 1: Complete scope of project with timetable, class based separation of concerns &   \\ 
        \hline
        09/15/20 & Sprint 2: Analytics library, data storage, grammar detail confirmations & Proposal  \\ 
        \hline
        09/29/20 & Sprint 3: Stop word recognition, human-readable output of processed data, environmental condition handling &   \\ 
        \hline
        10/13/20 & Sprint 4: Self-reference, duplication issues, ambiguity handling &   \\ 
        \hline
        10/27/20 & Sprint 5: Input validation, sanity checking, completed testing, suspicion analysis  &  \\ 
        \hline
        11/10/20 & Sprint 6: Final touches &   \\
        \hline
        11/24/20 & Wrap-up: Capstone work complete, final report, reflection essay  & Final meeting, establish date of presentation \\ 
        \hline
        \end{tabular}
        \caption{Project Time Table}
        \label{table:2}
    \end{center}
\end{table}

% Bibliography info
\bibliography{proposal-bib}
\bibliographystyle{unsrt}

\end{document}
