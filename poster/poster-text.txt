= The Basics = 
Files exist in filesystems, which can be scaled for a userbase from one to thousands of users.

On the many-users on one-system end of the scale, there's increased work efficiency from users sharing the same resources. 

= Problem Definition = 
But given the growing desire for companies to give their employees this level of efficient access to data, that data is at risk anytime security isn’t easy to establish for its users.

While typical access for a given file may be legitimate, when the owner of data does not adjust or monitor access, it’s easy for security requirements to relax. The data goes either unsecured or unmonitored.

Given this, it is extremely important that users can easily and efficiently control access to their data.

= Solution Basics =
In order to meet this goal, easy and effective means to protect information and resources must be made available to those responsible for its security. 
Being that natural language is the most direct way to input a command, we propose a program which allows for natural input that will both implement policies to build secure access and receive inquiries to grant or deny access to the inquirer.

It will accept everything from simple and straightforward privacy statements to fully customized schedules of access to highly confidential data.

= Data Description =
All types of data in a file system are at risk when access is not clearly defined. Our system will take user input and determine the intent of a given security policy or access inquiry for the extant data on a network or filesystem which implements our access control methods.

A given network with subjects, objects, and defined relationships can be interpreted as a directed labeled graph (vertices connected by edges)
\begin{enumerate}
    \item $N$ is a finite set of subjects $(S)$ and objects $(O)$, that may include an environmental condition.
    \item $\Sigma$ is a finite set of relationship types (labels for connections).
    \item $W$ is a number attached to a relationship between two subjects. This is a percentage of trust between two users.
    \item $E \subseteq N \times N \times \Sigma \times W$ represents the edges of existing connections, the relationships between subjects and objects, objects and other objects, and represents a general overview of the possible authorized interactions within that network\cite{morovat16}.
\end{enumerate}

= Solution Specifics =
Our system will use a well-formed notation for both specifying access control policies and authorizing access when inquiries against data are made. In this way, the definition of policies becomes simpler and more efficient, which will allow users to protect their assets under their own terms, and will ensure that requesters can feed access requests to the system just as simply.

Our solution stands as a faithful implementation of Dr. Morovat's own Policy Based Language for Access Control \cite{morovat16}. It will simultaneously respect the complexities of a network with subjects, objects, and environmental availability conditions while also achieving a simpler result. The Policy-Based Attribute Access Control model will allow its users to use a natural language to communicate policies, empowering authorized users to take control of their data and reduces risk using natural language requests such as “Bob can edit my tasklist documents on weekdays” and "only I can edit my tasklist documents after 1pm on Fridays".

Users will define policies and make inquiries in English via an access control interface. The program will transform user defined policies, using the well-formed format described below, into system rules. It will also transform user inquiries into the well-formed format and process these as system queries.
Given sentences will be in the format: Subject verb object [conditional(time/date)]. As an example, "Bob cannot update project-tasks.docx on weekends."

= End User Experience =
Our system must process natural user command sentences in a given structure within a basic UI, resulting in appending well-formatted data to a policy file in the user's directory. This will require a simple UI for access control input, which could easily be presented within an intranet-based web-application or desktop application. It will be flexible and responsive, as companies may wish to have more granular control over its presentation. In the event of conflict or necessary clarification for an input or authorization attempt, the program will allow for resolution accordingly.

= Functional Info =
The system will recognize 'Access' words like "Read", "write", and "modify", including common negations. Objects themselves may be referenced by filetype (i.e. "photos" = jpg, gif, etc, and "documents" = txt, docx, etc.). It will differentiate between types of entities in a given network as modeled above:
\begin{itemize}
    \item Target users, which get policies protecting them from unauthorized access
    \item Target resources, which get policies protecting them from unmanaged actions
\end{itemize}
It will group inquiries into two groups:
\begin{itemize}
    \item Attempting to perform an operation against resources like updating or deleting resource
    \item Attempting to access target users (e.g. Facebook may consider this in terms of 'tagging' in a photo or 'poking' a target user)
\end{itemize}
The well-formed format template we will use indicates the following:
\begin{itemize}
    \item Words in policy/ inquiry appear with order: subject, verb, object
    \item Words in rule/request appear with order: subject, action, object
\end{itemize}

= Flowchart Description =
Users will start our program via command line or graphical application. They may then type access control commands into the program. These commands may be written as natural-sounding sentences. The program will then parse the sentence into individual words. These individual words will be used with WordNet’s lexical database to ascertain their grammatical and syntactical significance. The program will use the grammatical and syntactical data to generate a well-formed policy rule for access control based on the original natural-sounding sentence. The newly generated policy will be cross examined with an existing policy text file to ensure the same policy does not already exist. If the newly generated policy does not exist in the policy text file, it will be appended to the policy text file. Dr. Morovat’s own program handles the security activities as determined by the policy rule or inquiry.

= Future =
We consider that this program will be useful for companies that emphasize team-based access to shared files, especially where leadership is comprised of users for whom it is not time-efficient to learn the details of things like `chmod` commands. Even Western Carolina University would benefit from implementing this approach, and it goes without saying that more general social networks such as Facebook might benefit from allowing users to take a more involved stance on how their data is seen by other users.
